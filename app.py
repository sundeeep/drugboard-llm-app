from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel, ConfigDict
from typing import Optional, Dict, Any, List
from langchain_community.chat_models import ChatPerplexity
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv
import json
import os
import re

# Load environment variables
load_dotenv()

# Create router instance
router = APIRouter()

# Create Pydantic models
class ChatRequest(BaseModel):
    message: str
    llm_model: Optional[str] = "llama-3.1-sonar-huge-128k-online"
    temperature: Optional[float] = 0.7
    
    model_config = ConfigDict(protected_namespaces=())

class User(BaseModel):
    username: str
    email: str
    password: str

class ChatResponse(BaseModel):
    users: List[Dict[str, str]]
    
    model_config = ConfigDict(protected_namespaces=())

def clean_json_response(response: str) -> str:
    """Clean the response to get only the JSON object"""
    # Remove markdown code blocks
    cleaned = response.replace("```json", "").replace("```", "").strip()
    
    # Find the first { and last }
    start = cleaned.find('{')
    end = cleaned.rfind('}') + 1
    
    if start != -1 and end != 0:
        cleaned = cleaned[start:end]
    
    # Remove any extra whitespace
    cleaned = cleaned.strip()
    
    return cleaned

@router.post("/welcome", response_model=ChatResponse)
async def chat_endpoint(request: ChatRequest, fastapi_request: Request):
    try:
        api_key = os.getenv("PPLX_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="API key not found")
        
        fastapi_request.headers.__dict__["_list"].append(
            (b"Authorization", f"Bearer {api_key}".encode())
        )

        chat_model = ChatPerplexity(
            model=request.llm_model,  
            temperature=request.temperature
        )

        system = """Return only a JSON array of users with this exact structure, no introduction, no conclusion and no other text and importantly no markdown formatting:

        username: It is the instagram kind of username with lowercase letters, numbers and underscore. (e.g., sundeep369, suresh_234, jayanth_1)
        emain: its combination of username@drugboard.ai , map the above username to the email and, domain: drugbaord.ai (e.g., sundeep369@drugboard.ai, suresh_234@drugboard.ai, jayanth_1@drugboard.ai)
        password: It is unique string generated by uuid.  
        Don't include the above example usernames, emails and password... Try out with the unique bible character names.
        The example JSON Format looks likes this!

        {{
          "users": [
            {{
              "username": "example",
              "email": "example@email.com",
              "password": "password123"
            }}
          ]
        }}"""
        
        human = "{question}"
        prompt = ChatPromptTemplate.from_messages([
            ("system", system),
            ("human", human)
        ])

        chain = prompt | chat_model
        response = chain.invoke({"question": request.message})
        
        # Clean the response
        cleaned_response = clean_json_response(response.content)
        
        try:
            # Parse the JSON response
            json_data = json.loads(cleaned_response)
            
            # Return the response in the expected format
            return ChatResponse(**json_data)
            
        except json.JSONDecodeError as e:
            print(f"JSON Decode Error: {e}")
            print(f"Attempted to parse: {cleaned_response}")
            raise HTTPException(status_code=500, detail="Failed to parse LLM response")
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))